rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isStaff() {
      return isSignedIn()
        && request.auth.token.keys().hasAny(['staff'])
        && request.auth.token.staff == true;
    }

    function isDemoByClaim() {
      return isSignedIn()
        && request.auth.token.keys().hasAny(['demo'])
        && (request.auth.token.demo == true);
    }

    function isDemoByUid() {
      return isSignedIn() && (request.auth.uid == "DEMO_UID_REPLACE_ME");
    }

    function isDemoUser() {
      return isDemoByClaim() || isDemoByUid();
    }

    function serverOwnedKeys() {
      return ['credits', 'stripe', 'plan', 'subscription', 'role', 'claims', 'stripeCustomerId'];
    }

    function isWritingServerOwnedFieldsOnCreate() {
      // For creates, simply block any server-owned keys in the incoming payload.
      return request.resource.data.keys().hasAny(serverOwnedKeys());
    }

    function isWritingServerOwnedFieldsOnUpdate() {
      // For updates, only block if the client is attempting to change a server-owned key.
      return request.resource.data.diff(resource.data).changedKeys().hasAny(serverOwnedKeys());
    }

    function onboardingFieldKeys() {
      return ['age', 'sex', 'height', 'goal', 'timeline', 'equipment', 'injuries', 'activities', 'experience', 'diet', 'likes', 'notifications', 'completedAt', 'version'];
    }

    function isSexValue(value) {
      return value == 'male' || value == 'female' || value == 'other';
    }

    function isGoalValue(value) {
      return value == 'lose-fat' || value == 'gain-muscle' || value == 'maintain' || value == 'recomp';
    }

    function isEquipmentValue(value) {
      return value == 'gym' || value == 'home-basic' || value == 'bodyweight' || value == 'none';
    }

    function isExperienceValue(value) {
      return value == 'beginner' || value == 'intermediate' || value == 'advanced';
    }

    function isDietValue(value) {
      return value == 'balanced' || value == 'low-carb' || value == 'vegetarian' || value == 'vegan' || value == 'keto';
    }

    function isValidOnboardingMap(data) {
      return data is map
        && data.keys().hasOnly(onboardingFieldKeys())
        && (!data.keys().hasAny(['age']) || (data.age is int && data.age >= 13 && data.age <= 100))
        && (!data.keys().hasAny(['sex']) || isSexValue(data.sex))
        && (!data.keys().hasAny(['height']) || (data.height is number && data.height >= 90 && data.height <= 260))
        && (!data.keys().hasAny(['goal']) || isGoalValue(data.goal))
        && (!data.keys().hasAny(['timeline']) || (data.timeline is int && data.timeline >= 1 && data.timeline <= 36))
        && (!data.keys().hasAny(['equipment']) || isEquipmentValue(data.equipment))
        && (!data.keys().hasAny(['experience']) || isExperienceValue(data.experience))
        && (!data.keys().hasAny(['diet']) || isDietValue(data.diet))
        && (!data.keys().hasAny(['injuries']) || data.injuries is string)
        && (!data.keys().hasAny(['activities']) || data.activities is string)
        && (!data.keys().hasAny(['likes']) || data.likes is string)
        && (!data.keys().hasAny(['notifications']) || data.notifications is bool)
        && (!data.keys().hasAny(['completedAt']) || data.completedAt is timestamp)
        && (!data.keys().hasAny(['version']) || data.version is int);
    }

    function isValidOnboardingMetaWrite() {
      let incomingKeys = request.resource.data.keys();
      let changedKeys = exists(resource.name)
        ? request.resource.data.diff(resource.data).changedKeys()
        : incomingKeys;
      return (
        (!changedKeys.hasAny(['completed']) ||
          !incomingKeys.hasAny(['completed']) ||
          request.resource.data.completed is bool)
        && (!changedKeys.hasAny(['completedAt']) ||
          !incomingKeys.hasAny(['completedAt']) ||
          request.resource.data.completedAt is timestamp)
        && (!changedKeys.hasAny(['updatedAt']) ||
          !incomingKeys.hasAny(['updatedAt']) ||
          request.resource.data.updatedAt is timestamp)
        && (!changedKeys.hasAny(['startedAt']) ||
          !incomingKeys.hasAny(['startedAt']) ||
          request.resource.data.startedAt is timestamp)
        && (!changedKeys.hasAny(['draftVersion']) ||
          !incomingKeys.hasAny(['draftVersion']) ||
          request.resource.data.draftVersion is int)
        && (!changedKeys.hasAny(['version']) ||
          !incomingKeys.hasAny(['version']) ||
          request.resource.data.version is int)
        && (!changedKeys.hasAny(['step']) ||
          !incomingKeys.hasAny(['step']) ||
          (request.resource.data.step is int && request.resource.data.step >= 0 && request.resource.data.step <= 4))
        && (!changedKeys.hasAny(['draft']) ||
          !incomingKeys.hasAny(['draft']) ||
          isValidOnboardingMap(request.resource.data.draft))
      );
    }

    function onboardingFieldChanged() {
      let hasOnboarding = request.resource.data.keys().hasAny(['onboarding']);
      let docExists = exists(resource.name);
      return hasOnboarding &&
        (!docExists ||
          request.resource.data.diff(resource.data).changedKeys().hasAny(['onboarding']));
    }

    function isValidOnboardingUpdate() {
      return !onboardingFieldChanged() ||
        isValidOnboardingMap(request.resource.data.onboarding);
    }

    function isValidMacroValue(value, max) {
      return value is number && value >= 0 && value <= max;
    }

    function isValidClientNutritionWrite() {
      let allowedKeys = ['calories', 'protein_g', 'carbs_g', 'fat_g', 'updatedAt'];
      return request.resource.data.keys().hasOnly(allowedKeys)
        && (!request.resource.data.keys().hasAny(['calories']) || isValidMacroValue(request.resource.data.calories, 10000))
        && (!request.resource.data.keys().hasAny(['protein_g']) || isValidMacroValue(request.resource.data.protein_g, 2000))
        && (!request.resource.data.keys().hasAny(['carbs_g']) || isValidMacroValue(request.resource.data.carbs_g, 2000))
        && (!request.resource.data.keys().hasAny(['fat_g']) || isValidMacroValue(request.resource.data.fat_g, 1000))
        && (!request.resource.data.keys().hasAny(['updatedAt']) || request.resource.data.updatedAt is timestamp);
    }

    function isValidCoachThreadWrite(uid) {
      // NOTE: Thread docs may include server-maintained fields (e.g. lastMessagePreview)
      // written by Cloud Functions (Admin SDK). Client updates should not be rejected
      // just because those fields exist, so avoid strict hasOnly() checks here.
      return request.resource.data is map
        && (!request.resource.data.keys().hasAny(['uid']) || request.resource.data.uid == uid)
        && (!request.resource.data.keys().hasAny(['status']) || request.resource.data.status is string)
        // Timestamps are typically written with serverTimestamp() sentinel values.
        // Avoid strict type checks here to prevent permission-denied on otherwise valid writes.
        && (!request.resource.data.keys().hasAny(['lastMessagePreview']) ||
          (request.resource.data.lastMessagePreview is string && request.resource.data.lastMessagePreview.size() <= 400));
    }

    function isValidCoachThreadMessageWrite() {
      // Allow optional assistant metadata fields to exist without blocking user writes.
      // Cloud Functions (Admin SDK) may write suggestions/meta; rules don't apply to those,
      // but the presence of extra keys would otherwise break merge updates.
      return request.resource.data is map
        && request.resource.data.role is string
        && (request.resource.data.role == 'user' || request.resource.data.role == 'assistant')
        && request.resource.data.content is string
        && request.resource.data.content.size() > 0
        && request.resource.data.content.size() <= 4000
        // createdAt is typically serverTimestamp() from the client.
        && (!request.resource.data.keys().hasAny(['suggestions']) || request.resource.data.suggestions is list);
    }

    match /publicConfig/{docId} {
      allow read: if true;
      allow write: if false;
    }

    match /app/publicConfig {
      allow read: if true;
      allow write: if false;
    }

    match /app/{docId} {
      allow read: if true;
      allow write: if false;
    }

    match /events/telemetry/{eventId} {
      allow create: if isSignedIn();
      allow read: if isStaff();
      allow update, delete: if false;
    }

    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid) && !isWritingServerOwnedFieldsOnCreate() && isValidOnboardingUpdate();
      allow update: if isOwner(uid) && !isWritingServerOwnedFieldsOnUpdate() && isValidOnboardingUpdate();
      allow delete: if false;

      match /coachThreads/{threadId} {
        allow read: if isOwner(uid);
        allow create: if !isDemoUser() && isOwner(uid) && isValidCoachThreadWrite(uid);
        allow update: if !isDemoUser() && isOwner(uid) && isValidCoachThreadWrite(uid);
        allow delete: if false;

        match /messages/{messageId} {
          allow read: if isOwner(uid);
          allow create: if !isDemoUser() && isOwner(uid) && isValidCoachThreadMessageWrite();
          allow update: if !isDemoUser() && isOwner(uid) && isValidCoachThreadMessageWrite();
          allow delete: if false;
        }

        // Legacy alias (older clients / experiments).
        // Keep permissions consistent with /messages to avoid hard-to-debug permission-denied errors.
        match /coachMessages/{messageId} {
          allow read: if isOwner(uid);
          allow create: if !isDemoUser() && isOwner(uid) && isValidCoachThreadMessageWrite();
          allow update: if !isDemoUser() && isOwner(uid) && isValidCoachThreadMessageWrite();
          allow delete: if false;
        }
      }

      match /scans/{scanId} {
        allow create: if !isDemoUser() && isOwner(uid)
          && request.resource.data.keys().hasOnly(['createdAt','note','notes','status'])
          && request.resource.data.status == 'queued';

        allow update: if !isDemoUser() && isOwner(uid)
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['note','notes']);

        allow read: if isOwner(uid);
        allow write: if false;
      }

      match /private/{doc=**} {
        allow read: if isOwner(uid);
        allow write: if false;
      }

      // Monetization entitlements (server-authored; user-readable)
      // Canonical path: /users/{uid}/entitlements/current
      match /entitlements/{docId} {
        allow read: if isOwner(uid);
        allow write: if false;
      }

      match /coach/{sub=**} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid) && !request.resource.id.matches('plan(/.*)?');
      }

      match /coach/plan/{rest=**} {
        allow read: if isOwner(uid);
        allow write: if false;
      }

      match /coachPlans/current {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /profile/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /settings/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /preferences/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /workoutPlans/{planId} {
        allow read: if isOwner(uid);
        allow write: if false;

        match /progress/{day} {
          allow read: if isOwner(uid);
          allow write: if false;
        }
      }

      // Current active workout plan pointer (written by Cloud Functions; readable by user UI).
      // Stored under a subcollection to keep the path a valid document reference.
      match /workoutPlans_meta/{docId} {
        allow read: if isOwner(uid);
        allow write: if false;
      }

      match /nutritionLogs/{day} {
        allow read: if isOwner(uid);
        allow create: if !isDemoUser() && isOwner(uid) && isValidClientNutritionWrite();
        allow update: if !isDemoUser() && isOwner(uid) && isValidClientNutritionWrite();
        allow delete: if false;

        match /entries/{entryId} {
          allow read: if isOwner(uid);
          allow create: if !isDemoUser() && isOwner(uid);
          allow update: if !isDemoUser() && isOwner(uid);
          allow delete: if !isDemoUser() && isOwner(uid);
        }
      }

      match /healthDaily/{day} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /nutrition/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);

        match /{sub=**} {
          allow read: if isOwner(uid);
          allow write: if !isDemoUser() && isOwner(uid);
        }
      }

      match /nutritionFavorites/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /nutritionTemplates/{docId} {
        allow read: if isOwner(uid);
        allow write: if !isDemoUser() && isOwner(uid);
      }

      match /meta/onboarding {
        allow read: if isOwner(uid);
        allow write: if isOwner(uid) && isValidOnboardingMetaWrite();
      }

      match /meta/{docId} {
        allow read: if docId != "onboarding" && isOwner(uid);
        allow write: if false;
      }
    }

    match /stripeEvents/{eventId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /telemetryEvents/{eventId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /stripe_events/{eventId} {
      allow read, write: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
